#!/bin/bash

set -euo pipefail

EPHEMERA_NOTES_REF="refs/notes/ephemera"
EPHEMERA_REMOTE_REFSPEC="+refs/notes/ephemera:refs/notes/ephemera"


die() {
    echo "ephemera: $*" >&2
    exit 1
}


usage() {
    cat <<'EOF'
Usage: git ephemera <command> [options]

Commands:
  save <path>...         Archive files and store as a git note
  restore                Extract files from a commit's note
  show                   Display note header/metadata
  list                   List archived filenames without extracting
  push [<remote>]        Push ephemera notes ref (default: origin)
  fetch [<remote>]       Fetch ephemera notes ref (default: origin)
  setup-remote [<remote>]  Configure remote fetch refspec for notes (default: origin)
  install-hooks          Install/update post-rewrite hook for commit tracking
  record-rewrite         Record commit rewrite history (used by post-rewrite hook)

Options for 'save':
  --commit <rev>     Target commit (default: HEAD)
  --message <text>   Optional message stored in header
  --strict           Fail if any path doesn't exist

Options for 'restore':
  --commit <rev>     Source commit (default: HEAD)
  --dest <dir>       Extraction directory (default: .)
  --force            Overwrite existing files
  --dry-run          List files without extracting

Options for 'show':
  --commit <rev>     Source commit (default: HEAD)
  --header           Print only the header
  --payload          Print only the base64 payload

Options for 'list':
  --commit <rev>     Source commit (default: HEAD)

Options for 'push':
  <remote>          Remote name (default: origin)

Options for 'fetch':
  <remote>          Remote name (default: origin)

Options for 'setup-remote':
  <remote>          Remote name (default: origin)

Options for 'install-hooks':
  --force           Overwrite existing post-rewrite hook

Examples:
  git ephemera save .ai/
  git ephemera save PRD.md PLAN.md
  git ephemera restore --commit abc123
  git ephemera list
  git ephemera push
  git ephemera fetch
  git ephemera setup-remote
  git ephemera install-hooks
EOF
}


in_git_repo() {
    git rev-parse --is-inside-work-tree >/dev/null 2>&1
}


resolve_commit() {
    local rev
    rev="${1:-HEAD}"

    git rev-parse --verify "${rev}^{commit}" 2>/dev/null
}


notes_show_raw() {
    local ref
    local commit

    ref="$1"
    commit="$2"

    git notes --ref "$ref" show "$commit"
}


# Parses a note into header and payload, storing results in global variables
# NOTE_HEADER and NOTE_PAYLOAD
# shellcheck disable=SC2034  # Variables are used by callers
parse_note() {
    local note_content="$1"
    local header=""
    local payload=""
    local in_payload=0

    while IFS= read -r line; do
        if [[ $in_payload -eq 0 && "$line" == "---" ]]; then
            in_payload=1
            continue
        fi
        if [[ $in_payload -eq 0 ]]; then
            header="$header$line"$'\n'
        else
            payload="$payload$line"
        fi
    done <<< "$note_content"

    NOTE_HEADER="$header"
    NOTE_PAYLOAD="$payload"
}


extract_payload() {
    local payload="$1"
    local dest="$2"
    local force="$3"
    local dry_run="$4"

    # Remove any whitespace from payload (handles wrapped base64)
    payload="$(echo "$payload" | tr -d '[:space:]')"

    if [[ $dry_run -eq 1 ]]; then
        echo "Would extract to: $dest"
        echo "Files:"
        echo "$payload" | base64 -d | tar -tzf -
        return
    fi

    mkdir -p "$dest"

    if [[ $force -eq 0 ]]; then
        # Check for file conflicts in archived paths
        local -a archived_files
        mapfile -t archived_files < <(echo "$payload" | base64 -d | tar -tzf -)
        local f
        for f in "${archived_files[@]}"; do
            # Skip directory entries (they end with /)
            [[ "$f" == */ ]] && continue
            if [[ -e "$dest/$f" ]]; then
                die "file '$dest/$f' already exists; use --force to overwrite"
            fi
        done
    fi

    echo "$payload" | base64 -d | tar -xzf - -C "$dest"
    echo "Restored files to $dest"
}


collect_paths() {
    local strict
    strict="$1"
    shift

    local -a patterns
    patterns=("$@")

    local -a found=()

    local repo_root
    repo_root="$(git rev-parse --show-toplevel)"

    local pattern
    for pattern in "${patterns[@]}"; do
        local -a matches=()

        shopt -s nullglob globstar
        # shellcheck disable=SC2206  # Intentional glob expansion
        matches=("$repo_root"/$pattern)
        shopt -u nullglob globstar

        # Filter to only existing paths
        local -a existing=()
        local m
        for m in "${matches[@]}"; do
            if [[ -e "$m" ]]; then
                existing+=("$m")
            fi
        done

        if [[ ${#existing[@]} -eq 0 ]]; then
            if [[ $strict -eq 1 ]]; then
                die "no files match pattern: $pattern"
            fi
            continue
        fi

        local match
        for match in "${existing[@]}"; do
            # If it's a directory, add all files recursively
            if [[ -d "$match" ]]; then
                while IFS= read -r -d '' file; do
                    local rel
                    rel="${file#"$repo_root"/}"
                    found+=("$rel")
                done < <(find "$match" -type f -print0)
            else
                local rel
                rel="${match#"$repo_root"/}"
                found+=("$rel")
            fi
        done
    done

    if [[ ${#found[@]} -eq 0 ]]; then
        die "no files to save"
    fi

    printf '%s\n' "${found[@]}"
}


create_note() {
    local commit
    local ref
    local message

    commit="$1"
    ref="$2"
    message="$3"
    shift 3

    local -a files
    files=("$@")

    local repo_root
    repo_root="$(git rev-parse --show-toplevel)"

    local full_sha
    if ! full_sha="$(resolve_commit "$commit")"; then
        die "invalid commit: $commit"
    fi

    local header
    header="ephemeraVersion: 1
encoding: tar+gzip+base64
createdAt: $(date -u +%Y-%m-%dT%H:%M:%SZ)
commit: $full_sha
commitHistory: []"

    if [[ -n "$message" ]]; then
        header="$header
message: $message"
    fi

    header="$header
paths:"

    local f
    for f in "${files[@]}"; do
        header="$header
  - $f"
    done

    local payload
    payload="$(cd "$repo_root" && tar -czf - "${files[@]}" | base64 | tr -d '\n')"

    local note_body
    note_body="$header
---
$payload"

    printf '%s\n' "$note_body" | git notes --ref "$ref" add -f -F - "$full_sha"

    echo "Saved ${#files[@]} file(s) to notes ref '$ref' on commit ${full_sha:0:12}"
}


cmd_save() {
    local commit="HEAD"
    local ref="ephemera"
    local message=""
    local strict=0
    local -a paths=()

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --commit)
                if [[ $# -lt 2 ]]; then
                    die "--commit requires an argument"
                fi
                commit="$2"
                shift 2
                ;;
            --message)
                if [[ $# -lt 2 ]]; then
                    die "--message requires an argument"
                fi
                message="$2"
                shift 2
                ;;
            --strict)
                strict=1
                shift
                ;;
            --)
                shift
                paths+=("$@")
                break
                ;;
            -*)
                die "unknown option: $1"
                ;;
            *)
                paths+=("$1")
                shift
                ;;
        esac
    done

    if [[ ${#paths[@]} -eq 0 ]]; then
        die "no paths specified"
    fi

    local -a files
    mapfile -t files < <(collect_paths "$strict" "${paths[@]}")

    create_note "$commit" "$ref" "$message" "${files[@]}"
}


cmd_restore() {
    local commit="HEAD"
    local ref="ephemera"
    local dest="."
    local force=0
    local dry_run=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --commit)
                if [[ $# -lt 2 ]]; then
                    die "--commit requires an argument"
                fi
                commit="$2"
                shift 2
                ;;
            --dest)
                if [[ $# -lt 2 ]]; then
                    die "--dest requires an argument"
                fi
                dest="$2"
                shift 2
                ;;
            --force)
                force=1
                shift
                ;;
            --dry-run)
                dry_run=1
                shift
                ;;
            -*)
                die "unknown option: $1"
                ;;
            *)
                die "unexpected argument: $1"
                ;;
        esac
    done

    local full_sha
    if ! full_sha="$(resolve_commit "$commit")"; then
        die "invalid commit: $commit"
    fi

    local note_content
    if ! note_content="$(git notes --ref "$ref" show "$full_sha" 2>/dev/null)"; then
        die "no note found on commit $commit"
    fi

    parse_note "$note_content"
    extract_payload "$NOTE_PAYLOAD" "$dest" "$force" "$dry_run"
}


cmd_show() {
    local commit="HEAD"
    local ref="ephemera"
    local show_header=0
    local show_payload=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --commit)
                if [[ $# -lt 2 ]]; then
                    die "--commit requires an argument"
                fi
                commit="$2"
                shift 2
                ;;
            --header)
                show_header=1
                shift
                ;;
            --payload)
                show_payload=1
                shift
                ;;
            -* )
                die "unknown option: $1"
                ;;
            *)
                die "unexpected argument: $1"
                ;;
        esac
    done

    if [[ $show_header -eq 1 && $show_payload -eq 1 ]]; then
        die "--header and --payload are mutually exclusive"
    fi

    local full_sha
    if ! full_sha="$(resolve_commit "$commit")"; then
        die "invalid commit: $commit"
    fi

    local note_content
    if ! note_content="$(git notes --ref "$ref" show "$full_sha" 2>/dev/null)"; then
        die "no note found on commit $commit"
    fi

    parse_note "$note_content"

    if [[ $show_payload -eq 1 ]]; then
        printf '%s\n' "$NOTE_PAYLOAD"
        return
    fi

    # Default output is header only.
    printf '%s' "$NOTE_HEADER"
}


cmd_list() {
    local commit="HEAD"
    local ref="ephemera"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --commit)
                if [[ $# -lt 2 ]]; then
                    die "--commit requires an argument"
                fi
                commit="$2"
                shift 2
                ;;
            -* )
                die "unknown option: $1"
                ;;
            *)
                die "unexpected argument: $1"
                ;;
        esac
    done

    local full_sha
    if ! full_sha="$(resolve_commit "$commit")"; then
        die "invalid commit: $commit"
    fi

    local note_content
    if ! note_content="$(git notes --ref "$ref" show "$full_sha" 2>/dev/null)"; then
        die "no note found on commit $commit"
    fi

    parse_note "$note_content"

    local payload
    payload="$(echo "$NOTE_PAYLOAD" | tr -d '[:space:]')"

    echo "$payload" | base64 -d | tar -tzf -
}


require_remote() {
    local remote="$1"

    if ! git remote get-url "$remote" >/dev/null 2>&1; then
        die "unknown remote: $remote"
    fi
}


cmd_push() {
    local remote="${1:-origin}"

    if [[ $# -gt 1 ]]; then
        die "unexpected argument: ${2}"
    fi

    require_remote "$remote"

    git push --no-verify "$remote" "$EPHEMERA_NOTES_REF"
}


cmd_fetch() {
    local remote="${1:-origin}"

    if [[ $# -gt 1 ]]; then
        die "unexpected argument: ${2}"
    fi

    require_remote "$remote"

    if ! git fetch "$remote" "$EPHEMERA_NOTES_REF:$EPHEMERA_NOTES_REF"; then
        die "failed to fetch '$EPHEMERA_NOTES_REF' from '$remote' (possible divergence; consider fetching with '$EPHEMERA_REMOTE_REFSPEC' and merging)"
    fi
}


cmd_setup_remote() {
    local remote="${1:-origin}"

    if [[ $# -gt 1 ]]; then
        die "unexpected argument: ${2}"
    fi

    require_remote "$remote"

    if git config --get-all "remote.${remote}.fetch" | grep -Fxq "$EPHEMERA_REMOTE_REFSPEC"; then
        return
    fi

    git config --add "remote.${remote}.fetch" "$EPHEMERA_REMOTE_REFSPEC"
}


# Helper to update note with new commit history entry
update_note_with_history() {
    local new_sha="$1"
    local old_sha="$2"
    local ref="${3:-ephemera}"

    local note_content
    if ! note_content="$(git notes --ref "$ref" show "$new_sha" 2>/dev/null)"; then
        return 0  # No note exists, nothing to update
    fi

    parse_note "$note_content"

    # Check if old_sha is already in commitHistory
    if echo "$NOTE_HEADER" | grep -q "^commitHistory:"; then
        if echo "$NOTE_HEADER" | grep -qF "$old_sha"; then
            return 0  # Already in history
        fi
    fi

    # Build new header with commitHistory
    local new_header="$NOTE_HEADER"

    # Add commitHistory field if not present
    if ! echo "$new_header" | grep -q "^commitHistory:"; then
        # Insert after commit: line using sed
        # shellcheck disable=SC2001  # sed pattern matching is clearer here
        new_header="$(echo "$new_header" | sed '/^commit:/a\
commitHistory: []')"
    fi

    # Append old_sha to commitHistory list
    # Replace "commitHistory: []" or "commitHistory: [sha1, ...]" with new entry
    # This handles both empty list and existing list cases
    # shellcheck disable=SC2001  # sed pattern matching is clearer here
    if echo "$new_header" | grep -q "^commitHistory: \[\]$"; then
        new_header="$(echo "$new_header" | sed "s/^commitHistory: \[\]/commitHistory: [$old_sha]/")"
    else
        # shellcheck disable=SC2001  # sed pattern matching is clearer here
        new_header="$(echo "$new_header" | sed "s/^commitHistory: \[/commitHistory: [$old_sha, /")"
    fi

    # Reconstruct the note body
    local new_note_body
    new_note_body="$new_header
---
$NOTE_PAYLOAD"

    # Write the updated note back
    printf '%s\n' "$new_note_body" | git notes --ref "$ref" add -f -F - "$new_sha" 2>/dev/null

    return 0
}


cmd_record_rewrite() {
    local ref="${1:-ephemera}"

    # Accept optional --ref argument
    if [[ "$ref" == "--ref" && $# -ge 2 ]]; then
        ref="$2"
    elif [[ $# -gt 1 ]]; then
        die "unexpected argument: ${2}"
    fi

    local count=0

    # Read stdin line by line: each line is "old_sha new_sha"
    while IFS=' ' read -r old_sha new_sha; do
        # Skip empty lines
        [[ -z "$old_sha" ]] && continue

        # Resolve full SHAs
        local full_old_sha
        local full_new_sha

        if ! full_old_sha="$(resolve_commit "$old_sha")"; then
            continue  # Skip invalid old SHA
        fi

        if ! full_new_sha="$(resolve_commit "$new_sha")"; then
            continue  # Skip invalid new SHA
        fi

        # Update note with history entry
        update_note_with_history "$full_new_sha" "$full_old_sha" "$ref"
        count=$((count + 1))
    done

    if [[ $count -gt 0 ]]; then
        echo "Processed $count rewrite pair(s)"
    fi
}


HOOK_TEMPLATE='#!/bin/bash
# git-ephemera hook to track commit rewrites
# (generated by: git ephemera install-hooks)
if command -v git >/dev/null 2>&1; then
  git ephemera record-rewrite <&0 || true
fi'


cmd_install_hooks() {
    local force=0

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force)
                force=1
                shift
                ;;
            *)
                die "unknown option: $1"
                ;;
        esac
    done

    local git_dir
    git_dir="$(git rev-parse --git-dir)"
    local hook_file="$git_dir/hooks/post-rewrite"

    mkdir -p "$(dirname "$hook_file")"

    if [[ -f "$hook_file" ]]; then
        if [[ $force -eq 0 ]]; then
            die "post-rewrite hook already exists. Use --force to overwrite, or edit the file manually."
        fi
        echo "Replacing existing post-rewrite hook (--force used)"
    fi

    printf '%s\n' "$HOOK_TEMPLATE" > "$hook_file"
    chmod +x "$hook_file"
    echo "Installed post-rewrite hook"
}


main() {
    if ! command -v git >/dev/null 2>&1; then
        die "git is required"
    fi

    if ! in_git_repo; then
        die "must be run from within a git repository"
    fi

    if [[ $# -lt 1 ]]; then
        usage
        exit 2
    fi

    local cmd
    cmd="$1"
    shift

    case "$cmd" in
        -h|--help|help)
            usage
            ;;
        save)
            cmd_save "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        show)
            cmd_show "$@"
            ;;
        list)
            cmd_list "$@"
            ;;
        push)
            cmd_push "$@"
            ;;
        fetch)
            cmd_fetch "$@"
            ;;
        setup-remote)
            cmd_setup_remote "$@"
            ;;
        install-hooks)
            cmd_install_hooks "$@"
            ;;
        record-rewrite)
            cmd_record_rewrite "$@"
            ;;
        *)
            usage
            die "unknown command: $cmd"
            ;;
    esac
}


main "$@"
